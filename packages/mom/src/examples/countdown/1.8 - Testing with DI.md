# Testing with Dependency Inversion

Let's come back on the Countdown example that was introduced in the lstore life cycle chaper.
As a reminder, this store implements a simple count-down counter that automatically updates itself very x milliseconds (1s by default) until it reaches 0.

## Using Dependencies

<!-- start:code src="src/services/timeService/timeService.types.ts" -->

```typescript
// timeService.types.ts
import { asyncIID } from "@asimojs/asimo";

export type IntervalId = number;
export type TimeoutId = number;

/**
 * Common time utilies (current time, intervals and timeouts)
 */
export interface TimeService {
    /** Get the current time in ms - cf. Date.now() */
    readonly now: number;
    /**
     * Register a callback that will be called at regular intervals
     * Wrapper on window.setInterval()
     * @param handler the callback function
     * @param delayMs the delay in ms (default: 0)
     **/
    setInterval(handler: () => void, delayMs: number): IntervalId;
    /**
     * Cancel an interval callback
     * Wrapper on window.clearInterval()
     * @param id the interval id returned by setInterval()
     * @see setInterval()
     **/
    clearInterval(id: IntervalId | undefined): void;
    /**
     * Register a callback that will be called once in x milliseconds
     * Wrapper on window.setTimeout()
     * @param handler the callback function
     * @param timeoutMs the delay in ms (default: 0)
     */
    setTimeout(handler: () => void, timeoutMs?: number): TimeoutId;
    /**
     * Cancel a timeout callback before it gets executed
     * Wrapper on window.clearTimeout()
     * @param id the timeout id returned by setTimeout()
     * @see setTimeout()
     */
    clearTimeout(id: TimeoutId | undefined): void;
}

export const TimeServiceIID = asyncIID<TimeService>("mom.services.TimeService");
```

<!-- end:code -->

<!-- start:code src="src/examples/countdown/countdown.ts" -->

```typescript
// countdown.ts
export const CountDown = storeFactory(CountDownIID, (m, params) => {
    const { initValue = 10, intervalMs = 1000, autoStart = false } = params;
    let timeService: TimeService | null = null;

    const model = m.makeAutoObservableModel({
        value: initValue,
        get isRunning() {
            return controller.intervalId > 0;
        },

        /** Start the countdown */
        start(): void {
            if (controller.intervalId || !timeService) return; // already running
            controller.intervalId = timeService.setInterval(() => {
                runInAction(() => {
                    if (model.value > 0) {
                        model.value--;
                    }
                    if (model.value === 0) {
                        model.stop();
                    }
                });
            }, intervalMs);
        },
        /** Stop the countdown */
        stop(): void {
            if (!controller || !timeService) return; // already stopped
            timeService.clearInterval(controller.intervalId);
            controller.intervalId = 0;
        },
        /** Reset the countdown counter */
        reset(): void {
            model.value = initValue;
        },
    });

    const controller = m.makeAutoObservableController({
        /** interval identifier created by setInterval() - 0 if not set */
        intervalId: 0,
        async init() {
            timeService = await m.context.fetch(TimeServiceIID);
            autoStart && model.start();
        },
        dispose() {
            model.stop();
        },
    });
});
```

<!-- end:code -->

## Testig with fake Dependencies

<!-- start:code src="src/services/timeService/timeService.mock.ts#controllerAPI" -->

```typescript
// timeService.mock.ts
export interface FakeTimeServiceController {
    /** Move the current time by x ms and executes all interval / timeout callbacks */
    moveTime(durationMs: number): void;
    /** Move the current time to the next callback and execute it */
    executeNextCallback(): boolean;
    /** Return the number of intervals still active */
    readonly numberOfActiveIntervals: number;
    /** Return the numbe of timeouts still active */
    readonly numberOfActiveTimeouts: number;
    /** Reset internal state */
    reset(): void;
}
```

<!-- end:code -->

<!-- start:code src="src/examples/countdown/countdown.spec.ts#start" -->

```typescript
// countdown.spec.ts
describe("CountDown", () => {
    let context: IoCContainer, store: CountDownStore, timeController: FakeTimeServiceController;

    beforeEach(() => {
        context = createContainer({ parent: asm, name: "test:CountDown" });
        timeController = createFakeTimeService(context);
    });

    afterEach(() => {
        store && disposeStore(store);
    });

    async function init(params?: CountDownDef["params"], awaitInitComplete = true) {
        store = createStore({ $store: CountDown, $context: context, ...params });
        if (awaitInitComplete) {
            await store["#initComplete"];
        }
    }
```

<!-- end:code -->

<!-- start:code src="src/examples/countdown/countdown.spec.ts" -->

```typescript
// countdown.spec.ts
it("should support default values", async () => {
    await init({}, false);
    expect(store["#ready"]).toBe(false); // async init

    expect(store.value).toBe(10);
    expect(store.isRunning).toBe(false);

    await store["#initComplete"];
    expect(store["#ready"]).toBe(true);

    // test that the default autoStart is false
    timeController.moveTime(2000); // 2s
    expect(store.value).toBe(10); // unchanged -> not started

    // test the default intervalMs is 1000ms
    store.start();
    timeController.moveTime(999);
    expect(store.value).toBe(10); // not yet

    timeController.moveTime(1);
    expect(store.value).toBe(9); // countdown started
});
```

<!-- end:code -->

<!-- start:code src="src/examples/countdown/countdown.spec.ts#start-stop" -->

```typescript
// countdown.spec.ts
it("should support start / stop (autoStart false)", async () => {
    await init({ intervalMs: 5 });
    expect(store["#ready"]).toBe(true);
    expect(store.value).toBe(10);
    expect(store.isRunning).toBe(false);

    store.start();
    expect(store.isRunning).toBe(true);
    timeController.moveTime(7);
    expect(store.value).toBe(9);
    timeController.moveTime(5);
    expect(store.value).toBe(8);
    expect(store.isRunning).toBe(true);

    store.stop();
    expect(store.isRunning).toBe(false);

    timeController.moveTime(100);
    expect(store.value).toBe(8); // unchanged
    expect(store.isRunning).toBe(false);

    store.start();
    expect(store.isRunning).toBe(true);
    timeController.moveTime(7);

    expect(store.value).toBe(7);
});
```

<!-- end:code -->
