# Store with sub-stores: mount() and unmount()

Let's imagine that we need to implement a file explorer User Interface (e.g. to pick a file in a file system). At some stage we will need to represent a folder, so it will make sense to create a FolderStore to manage the folder logic.

In a simplified version the FolderStore model would need to expose

-   the folder name
-   the folder path
-   an 'expanded' property to tell if the folder view should be expanded or collapsed (in which case sub-folders wouldn't need to be loaded as they wouldn't be displayed)
-   the list of file names contained in the folder
-   the list of sub-folders contained in the folder (and of course sub-folders would be represented as child FolderStores)

Last but not least, it would be also good to be able to load a FolderStore from a JSON structure like:

<!-- start:code src="src/examples/folder/folder.types.ts#folderdata" -->

```typescript
// folder.types.ts
export interface FolderData {
    name?: string;
    files?: string[];
    folders?: FolderData[];
}
```

<!-- end:code -->

From what we already saw in the previous chapter, this would result in a store definition like:

<!-- start:code src="src/examples/folder/folder.types.ts#folderdata" -->

```typescript
// folder.types.ts
type FolderDef = {
    params: {
        /** The folder data retrieved from the domain layer */
        data: FolderData;
        /** The parent folder or null for the root folder */
        parent: FolderStore | null;
        /** Tell if the folder should be expanded */
        expanded?: boolean;
    };
    model: {
        /** The folder name */
        name: string;
        /** The folder path (e.g. "/foo/bar") */
        path: string;
        /** Tell if the folder view should be expanded or collapsed */
        isExpanded: boolean;
        /** The files contained in this folder */
        files: string[];
        /** The sub-folders contained in this folder */
        folders: FolderStore[];

        /** Change the expand value */
        expand(expanded: boolean): void;
        /** Recursively expand or collapse the folder and its sub-folders */
        expandAll(expanded: boolean): void;
        /** Change the folder name */
        setName(name: string): void;
    };
};
```

<!-- end:code -->

## Loading sub-stores eagerly

The simplest implementation consists in loading sub-stores _eagerly_ - i.e. at store creation time without any consideration for the _expanded_ attribute (so sub-stores will be loaded even if they are not displayed).

This can be done in 2 ways:

-   either in the model declaration (i.e. in the _makeAutoObservableModel_ call)
-   or in the store init (i.e. in the _makeAutoObservableController_ init method)

In this particular case, the choice was made to pass the parent store as params to allow to process the folder _path_ as a computed property. This is easy to do through the **m.store** property exposed on the store context _m_. The only catch is that this property is only defined after _makeAutoObservableModel_ has been called, so in this example we dont't have any other choice than loading the sub-stores in the store init method, as shown below:

<!-- start:code src="src/examples/folder/folder.eager.ts#main" -->

```typescript
// folder.eager.ts
export const Folder = storeFactory(FolderIID, (m, params) => {
    const { data, parent, expanded = false } = params;

    const model = m.makeAutoObservableModel({
        name: data.name ?? "[Unnamed folder]",
        get path() {
            if (!parent) return "/";
            if (parent.path === "/") return `/${model.name}`;
            return `${parent.path}/${model.name}`;
        },
        isExpanded: expanded,
        files: data.files ?? [],
        folders: [], // init

        /** Change the expand value */
        expand(expanded: boolean) {
            model.isExpanded = expanded;
        },
        /** Recursively expand or collapse the folder and its sub-folders */
        expandAll(expanded: boolean) {
            model.expand(expanded);
            for (const folder of model.folders) {
                folder.expandAll(expanded);
            }
        },
        /** Change the folder name */
        setName(name: string) {
            model.name = name;
        },
    });

    m.makeAutoObservableController({
        init() {
            model.folders = data.folders?.map((f) => m.mount({ $store: Folder, data: f, parent: m.store })) ?? [];
        },
    });
});
```

<!-- end:code -->

As you can see, loading a sub-store is as easy as calling the **m.mount()** method that returns a new store instance. The sub-store will be automatically connected ot its parent store and will be automatically disposed when the parent gets disposed (i.e. the sub-store _dispose_ methods will be called).

The _mount_ method takes the same argument as the _createStore_ function that is used to create root stores. Of course _createStore_ must not be used to create sub-stores as it won't create the parent/child relationship that allows sub-stores to get disposed when the parent gets disposed.

## Loading sub-stores on-demand

As previously stated, we don't need to load sub-folder stores before they get displayed (at least in this example). This can be easily done by loading the sub-stores dynamically:

<!-- start:code src="src/examples/folder/folder.ts#main" -->

```typescript
// folder.ts
export const Folder = storeFactory(FolderIID, (m, params) => {
    const { data, parent, expanded = false } = params;
    let defaultChildExpanded = false;

    const model = m.makeAutoObservableModel({
        name: data.name ?? "[Unnamed folder]",
        get path() {
            if (!parent) return "/";
            if (parent.path === "/") return `/${model.name}`;
            return `${parent.path}/${model.name}`;
        },
        isExpanded: expanded,
        files: data.files ?? [],
        folders: [], // loaded dynamically

        /** Change the expand value */
        expand(expanded: boolean) {
            model.isExpanded = expanded;
            controller.loadSubFolders();
        },
        /** Recursively expand or collapse the folder and its sub-folders */
        expandAll(expanded: boolean) {
            model.expand(expanded);
            defaultChildExpanded = expanded;
            for (const folder of model.folders) {
                folder.expandAll(expanded);
            }
        },
        /** Change the folder name */
        setName(name: string) {
            model.name = name;
        },
    });

    const controller = m.makeAutoObservableController({
        loadCompleted: false,
        init() {
            this.loadSubFolders();
        },
        loadSubFolders() {
            // only load the sub-folders if the folder is expanded
            if (!this.loadCompleted && model.isExpanded) {
                this.loadCompleted = true;
                for (const dataFolder of data.folders ?? []) {
                    model.folders.push(
                        // m.mount returns a new FolderStore instance
                        m.mount({
                            $store: Folder,
                            data: dataFolder,
                            parent: m.store,
                            expanded: defaultChildExpanded,
                        }),
                    );
                }
            }
        },
    });
});
```

<!-- end:code -->

## Sub-store views

As sub-folder stores are directly exposed on the parent model, it is easy to call the sub-store views directly (no need to save them in a React state like for root stores):

<!-- start:code src="src/examples/folder/folder.view.tsx#main" -->

```tsx
// folder.view.tsx
export const FolderView = observer(({ store, className }: ViewProps<FolderStore>) => {
    return (
        <div className={className}>
            <div>
                <ExpandIcon expanded={store.isExpanded} onClick={() => store.expand(!store.isExpanded)} />
                {store.name}
                {store.path === "/" && (
                    <>
                        <button onClick={() => store.expandAll(true)}> Expand All </button>
                        <button onClick={() => store.expandAll(false)}> Collapse All </button>
                    </>
                )}
            </div>
            {store.isExpanded && (
                <ul className="p-2">
                    {store.folders.map((folder) => (
                        <li key={folder["#id"]}>
                            <FolderView store={folder} />
                        </li>
                    ))}
                    {store.files.map((file, index) => (
                        <li key={`file:${index}`}>{file}</li>
                    ))}
                </ul>
            )}
        </div>
    );
});
```

<!-- end:code -->

You can note the convenient usage of the store _#id_ meta-data that can be used as key attribute for React lists.

## Disposing sub-stores

Mom also offer the possibility to unmount sub-stores dynamically to free-up some memory when sub-stores are infrequently used.

The _m.unmount()_ method will recursively dispose the store passed as argument and will return null. This allows to unmount and remove a sub-store reference in one line:

```typescript
// unmount doesn't automatically set the sub-store reference to null
// but the sub-store #state will be DISPOSING or DISPOSED (depending on whether
// the sub-store dispose() is synchronous or asynchrounous)
model.mySubStore = m.unmount(model.mySubStore);
```
