# Testing with Dependency Inversion

Let's come back on the Countdown example that was introduced in the store life cycle chapter.
As a reminder, this store implements a simple count-down counter that automatically updates itself very x milliseconds (1s by default).
In the original example the code didn't use any DI container and the store called `window.setInterval` / `window.clearInterval` directly.

So let's see how the same code could be modified to use Dependency Inversion and how we can use it to simplify & speed-up our tests.

## Using Dependencies

Of course before modifying the code we need to identify our external dependencies and define which DI interface
could be used (and if we need to create one ourselves).
Again, in this particular example, we only need access to the `setInterval` / `clearInterval` browser APIs - and
fortunately mum already provides a API wrapper for that: [TimeService]

[TimeService]: ../../services/timeService/timeService.types.ts

This service offers the 3 elements associated to any DI interface:

-   an interface or type definition (and its ID token) for the interval, timeout and current time APIs (aka. `setInterval`, `setTimeout` and `Date.now()`)
-   an implementation using the system/browser APIs (used by default and registered in the root asm container).
-   a fake implementation to use in a test environment (cf. below)

The [TimeService] API looks like this:

<!-- start:code src="src/services/timeService/timeService.types.ts" -->

```typescript
// timeService.types.ts
import { asyncIID } from "@asimojs/asimo";

export type IntervalId = number;
export type TimeoutId = number;

/**
 * Common time utilies (current time, intervals and timeouts)
 */
export interface TimeService {
    /** Get the current time in ms - cf. Date.now() */
    readonly now: number;
    /**
     * Register a callback that will be called at regular intervals
     * Wrapper on window.setInterval()
     * @param handler the callback function
     * @param delayMs the delay in ms (default: 0)
     **/
    setInterval(handler: () => void, delayMs: number): IntervalId;
    /**
     * Cancel an interval callback
     * Wrapper on window.clearInterval()
     * @param id the interval id returned by setInterval()
     * @see setInterval()
     **/
    clearInterval(id: IntervalId | undefined): void;
    /**
     * Register a callback that will be called once in x milliseconds
     * Wrapper on window.setTimeout()
     * @param handler the callback function
     * @param timeoutMs the delay in ms (default: 0)
     */
    setTimeout(handler: () => void, timeoutMs?: number): TimeoutId;
    /**
     * Cancel a timeout callback before it gets executed
     * Wrapper on window.clearTimeout()
     * @param id the timeout id returned by setTimeout()
     * @see setTimeout()
     */
    clearTimeout(id: TimeoutId | undefined): void;
}

export const TimeServiceIID = asyncIID<TimeService>("mom.services.TimeService");
```

<!-- end:code -->

Having done that, the countdown implementation now needs to be modified to use this interface.
This requires very small changes:

1. import the dependency interface and IID: `import { TimeService, TimeServiceIID } from "@/services/timeService/timeService.types";`
2. retrieve the dependency through `timeService = await m.context.fetch(TimeServiceIID);`. In this example, the dependency is
   retrieved once and for all in the store _init()_ because it is a prerequisite for this component, but in the general case it is usually
   better to retrieve the dependency when needed to optimize code progressive load.
3. use it - cf. `timeService.setInterval` and `timeService.clearInterval` in the _start()_ and _stop()_ methods:

<!-- start:code src="src/examples/countdown/countdown.ts" -->

```typescript
// countdown.ts
export const CountDown = storeFactory(CountDownIID, (m, params) => {
    const { initValue = 10, intervalMs = 1000, autoStart = false } = params;
    let timeService: TimeService | null = null;

    const model = m.makeAutoObservableModel({
        value: initValue,
        get isRunning() {
            return controller.intervalId > 0;
        },

        /** Start the countdown */
        start(): void {
            if (controller.intervalId || !timeService) return; // already running
            controller.intervalId = timeService.setInterval(() => {
                runInAction(() => {
                    if (model.value > 0) {
                        model.value--;
                    }
                    if (model.value === 0) {
                        model.stop();
                    }
                });
            }, intervalMs);
        },
        /** Stop the countdown */
        stop(): void {
            if (!controller || !timeService) return; // already stopped
            timeService.clearInterval(controller.intervalId);
            controller.intervalId = 0;
        },
        /** Reset the countdown counter */
        reset(): void {
            model.value = initValue;
        },
    });

    const controller = m.makeAutoObservableController({
        /** interval identifier created by setInterval() - 0 if not set */
        intervalId: 0,
        async init() {
            timeService = await m.context.fetch(TimeServiceIID);
            autoStart && model.start();
        },
        dispose() {
            model.stop();
        },
    });
});
```

<!-- end:code -->

## Testig with fake Dependencies

With this change it is now possible to use a fake TimeService implementation to peform fine-grained tests on this store.

In a general manner, fake implementations provide 2 sets of interfaces:

-   the public interface exposed through the IID token
-   a controller interface to trigger external events that will surface through the public interface. In the case
    of the TimeService API, the controller allows to
    -   move time step by step (and trigger the pending interval / timeout callbacks)
    -   get insight on the system internal state (cf. _numberOfActiveIntervals_ / _numberOfActiveTimeouts_)
    -   reset the the internal state (e.g. to reuse the dependency in another test if we don't want to rebuild the full test environment)

In the current case the Fake TimeService Controller API looks like this:

<!-- start:code src="src/services/timeService/timeService.types.ts#controllerAPI" -->

```typescript
// timeService.mock.ts
export interface FakeTimeServiceController {
    /** Move the current time by x ms and executes all interval / timeout callbacks */
    moveTime(durationMs: number): void;
    /** Move the current time to the next callback and execute it */
    executeNextCallback(): boolean;
    /** Return the number of intervals still active */
    readonly numberOfActiveIntervals: number;
    /** Return the numbe of timeouts still active */
    readonly numberOfActiveTimeouts: number;
    /** Reset internal state */
    reset(): void;
}
```

<!-- end:code -->

That being said, we now need to use this fake implementation in our tests. This of course first requires to

-   create a sub-container to manage the test dependencies. This container should derive from the parent `asm`
    container to benefit from all default implementations.
-   create fake implementations and register them in the test container. In this particular example we just need
    to fake the TimeService API and this is
    done through the `createFakeTimeService(context)` factory exposed by the TimeService mock implementation:

<!-- start:code src="src/examples/countdown/countdown.spec.ts#start" -->

```typescript
// countdown.spec.ts
describe("CountDown", () => {
    let context: IoCContainer, store: CountDownStore, timeController: FakeTimeServiceController;

    beforeEach(() => {
        context = createContainer({ parent: asm, name: "test:CountDown" });
        timeController = createFakeTimeService(context);
    });

    afterEach(() => {
        store && disposeStore(store);
    });

    async function init(params?: CountDownDef["params"], awaitInitComplete = true) {
        store = createStore({ $store: CountDown, $context: context, ...params });
        if (awaitInitComplete) {
            await store["#initComplete"];
        }
    }
```

<!-- end:code -->

In the previous example, you will note the presence of an `init()` function that creates the store
instance. This is a very common pattern in mom tests as we frequently need to create stores with
different parameters - and usually wait for the store init completion before starting the actual test assertions -
this is why this code is not included in the `beforeEach` implementation.

With all this proper setup, we can now easily test the Countdown store. Here is for instance
how the default parameter values can be validated:

<!-- start:code src="src/examples/countdown/countdown.spec.ts" -->

```typescript
// countdown.spec.ts
it("should support default values", async () => {
    await init({}, false);
    expect(store["#ready"]).toBe(false); // async init

    expect(store.value).toBe(10);
    expect(store.isRunning).toBe(false);

    await store["#initComplete"];
    expect(store["#ready"]).toBe(true);

    // test that the default autoStart is false
    timeController.moveTime(2000); // 2s
    expect(store.value).toBe(10); // unchanged -> not started

    // test the default intervalMs is 1000ms
    store.start();
    timeController.moveTime(999);
    expect(store.value).toBe(10); // not yet

    timeController.moveTime(1);
    expect(store.value).toBe(9); // countdown started
});
```

<!-- end:code -->

We can also test the differet store methods:

<!-- start:code src="src/examples/countdown/countdown.spec.ts#start-stop" -->

```typescript
// countdown.spec.ts
it("should support start / stop (autoStart false)", async () => {
    await init({ intervalMs: 5 });
    expect(store["#ready"]).toBe(true);
    expect(store.value).toBe(10);
    expect(store.isRunning).toBe(false);

    store.start();
    expect(store.isRunning).toBe(true);
    timeController.moveTime(7);
    expect(store.value).toBe(9);
    timeController.moveTime(5);
    expect(store.value).toBe(8);
    expect(store.isRunning).toBe(true);

    store.stop();
    expect(store.isRunning).toBe(false);

    timeController.moveTime(100);
    expect(store.value).toBe(8); // unchanged
    expect(store.isRunning).toBe(false);

    store.start();
    expect(store.isRunning).toBe(true);
    timeController.moveTime(7);

    expect(store.value).toBe(7);
});
```

<!-- end:code -->

More examples in the [Countdown test suite][CountdownSpec].

[CountdownSpec]: ../../examples/countdown/countdown.spec.ts
