# Params and computed values

The previous example was very simplistic and doesn't really correspond to real life scenarios, for instance

-   we may want to define the initial counter value instead of always starting at 1
-   we may want to expose a formatted value, instead of only exposing the raw counter (e.g. display "001" instead of "1")

The first problem can be solved by passing **params** to the store factory. For instance we could

-   define an optional parameter to define the _default value_
-   define an optional parameter to define the _number of digits_ to use for the counter formatting

## Params definition

This is where the _params_ section in the store definition type comes into play:

<!-- start:code src="src/examples/counter/counter.types.ts#main" -->

```typescript
// counter.types.ts
type CounterDef = {
    params: {
        /** The initial counter value - default: 0 */
        value?: number;
        /** Minimal number of digits in the formatted display - default: 2 */
        minFormatDigits?: number;
    };
    model: {
        /** The counter value - default: 0 */
        value: number;
        /** Counter value formatted according to minFormatDigits - e.g. "007" */
        formattedValue: string;
        /** Increment the counter by the given quantity (can be negative) - default: 1 */
        increment(quantity?: number): void;
        /** Reset the counter to a given value (default: 0) */
        reset(value?: number): void;
    };
};
```

<!-- end:code -->

As we will see below, the _params_ object will be passed to the store implementation function.

## Computed values

The second problem can be solved thanks to _[mobx computed properties][mobx-computed]_ that allow to bind an observable object
processing to other properties (in this case the _value_).

[mobx-computed]: https://mobx.js.org/computeds.html

Here is how it looks like in the full implementation:

<!-- start:code src="src/examples/counter/counter.ts#main" -->

```typescript
// counter.ts
export const CounterStore = storeFactory(CounterSID, (m, params) => {
    const minFormatDigits = params.minFormatDigits ?? 2;

    const model = m.makeAutoObservableModel({
        value: params.value ?? 0,
        get formattedValue() {
            // Format the counter with padding "0" at the start - e.g. "03"
            return String(model.value).padStart(minFormatDigits, "0");
        },

        /** Increment the counter by the given quantity (can be negative) - default: 1 */
        increment(quantity = 1) {
            model.value += quantity;
        },
        /** Reset the counter */
        reset(value = 0) {
            model.value = value;
        },
    });
});
```

<!-- end:code -->

Of course the view needs to be updated accordingly:

<!-- start:code src="src/examples/counter/counter.view.tsx#main" -->

```typescript
// counter.view.tsx
export const CounterView = observer(({ store, className }: ViewProps<Counter>) => {
    return (
        <div className={className}>
            <div>Counter: {store.formattedValue}</div>
            <button onClick={() => store.increment(1)}>Increment</button>
            <button onClick={() => store.increment(-1)}>Decrement</button>
            <button onClick={() => store.reset()}>Reset</button>
        </div>
    );
});
```

<!-- end:code -->

## Params usage

Last but not least, we can now pass params when instantiating the store:

<!-- start:code src="src/examples/counter/counter.example.tsx#main" -->

```typescript
// counter.example.tsx
export const HelloCounter = () => {
    const [store] = useState(() => loadStore({ $store: CounterStore, value: 42, minFormatDigits: 3 }));
    return (
        <div>
            Counter: <CounterView store={store} />
        </div>
    );
};
```

<!-- end:code -->

Of course params are fully typed and errors will show up in case of invalid or missing (non-optional) params.
