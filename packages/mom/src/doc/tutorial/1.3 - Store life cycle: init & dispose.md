# Store life cycle: init() and dispose()

Like for React components, stores need to support the possibility to run specific code at **creation** and **disposal** times.
For instance it is very frequent to fetch data from the server when a store initializes - conversaly, we may need to run specific
code to free up some resources when a store get unmounted/disposed.

These use cases are so frequent (in particular the asynchronous initialization) that mom automatically exposes some life-cycle
state properties on every store.

## Store life cycle states

Each store instance goes through the following stages that are exposed through the **#state** enum property:

-   INITIALIZING: initialization has started and is not complete (in case of asynchronous initialization)
-   READY: the store is initialized (init complete) and disposal has not started - this is where the store spends most of its life
-   DISPOSING: the store disposal started and disposal is not complete (dispose can also be asynchronous)
-   DISPOSED: the store is disposed and will not function anymore. Store references should be removed (remaining data can be read though)

As the _ready_ state is usually the most important information for the store view (e.g. to display a processing indicator), a specifi **#ready** property
is also exposed on the store models. This property can be used like this:

```typescript
export const MyStoreView = observer(({ store }: ViewProps<MyStore>) => {
    if (!store["#ready"]) return <div> Loading... </div>;
    return <div>[...]</div>;
});
```

## Store controller

Technically mom allows to define optional _init()_ and _dispose()_ functions to handle logic at store creation or disposal times.
These functions are meant to be used by mom only and will automatically be called without any explicit call from the store users:

-   _init()_ will be called immediately after the store creation (i.e. immediately after the store factory function returns)
-   _dispose()_ will be called when the store is unmounted (cf. store with child store chapter)

These methods should not be exposed on the store model - otherwise they would be visible to all store users - this is why mom offers the possibility
to define them on a second observable object that can be used to store private data and methods (cf. the **makeAutoObservableController**
example below). For lack of better name, this object is by convention called the _controller_ (as it contains the controller private state and logic - even
though the controller public methods are exposed on the model object).

Note: both functions can be synchronous or asynchronous (through either async or generator functions - cf. below).

Note 2: init() is called after the store factory has returned because mom's philosophy is to always create the store synchronously in order to no block
the initial view rendering (even if the store is not _ready_):

-   when init() is synchronous, the store will be immediately in _READY_ state when used by the React's view
-   when init() is asynchronous, the store may not be ready during the first view rendering - this is why the **store["#ready"]** property should
    be interpreted to display some processing indicator

## CountDown example

As an example let's consider a CountDown module that allows to display a count-down counter that automatically updates itself every second.

A simple implementation of the store API would look like this:

<!-- start:code src="src/examples/countdown/countdown.types.ts#main" -->

```typescript
// countdown.types.ts
type CountDownDef = {
    params: {
        /** The initial countdown counter value - default: 10 */
        initValue?: number;
        /** The countdown time interval in ms - default 1000 */
        intervalMs?: number;
        /** Tell if the countdown should automatically start at init */
        autoStart?: boolean;
    };
    model: {
        /** The countdown counter value */
        value: number;
        /** Tell if the countdown timer is running or stopped */
        isRunning: boolean;

        /** Start the countdown */
        start(): void;
        /** Stop the countdown */
        stop(): void;
        /** Reset the countdown counter */
        reset(): void;
    };
};
```

<!-- end:code -->

From these specifications, we can see that this module needs to perform some specific logic:

-   at init: the counter must be started if the autoStart param is true
-   at disposal: the internal interval must be cleared (if not already done) to avoid running an infinite timer interval in the background

This translates into the following implementation:

<!-- start:code src="src/examples/countdown/countdown.ts#main" -->

```typescript
// countdown.ts
export const CountDown = storeFactory(CountDownIID, (m, params) => {
    const { initValue = 10, intervalMs = 1000, autoStart = false } = params;

    const model = m.makeAutoObservableModel({
        value: initValue,
        get isRunning() {
            return controller.intervalId > 0;
        },

        /** Start the countdown */
        start(): void {
            if (controller.intervalId) return; // already running
            // note: DI context should be used instead of using setInterval directly
            controller.intervalId = setInterval(() => {
                runInAction(() => {
                    if (model.value > 0) {
                        model.value--;
                    }
                    if (model.value === 0) {
                        model.stop();
                    }
                });
            }, intervalMs);
        },
        /** Stop the countdown */
        stop(): void {
            if (!controller.intervalId) return; // already stopped
            // note: DI context should be used instead of using clearInterval directly
            clearInterval(controller.intervalId);
            controller.intervalId = 0;
        },
        /** Reset the countdown counter */
        reset(): void {
            model.value = initValue;
        },
    });

    const controller = m.makeAutoObservableController({
        /** interval identifier created by setInterval() - 0 if not set */
        intervalId: 0,
        init() {
            autoStart && model.start();
        },
        dispose() {
            model.stop();
        },
    });
});
```

<!-- end:code -->

Note: you may have spotted the mom's _runInAction()_ call in the setInterval callback - this will be explained later on in the reactivity chapter

## Store asynchronous initialization / disposal (async vs. generator functions)

The previous example was using synchronous init and dipose functions, however we frequently need asynchronous functions instead (at least for init) -
for instance to fetch data from the server during the store initialization.

Imagine that you need to fetch some data from the server through an async _fetchData()_ function that returns a list of JSON objects typed as _MyData[]_.
This can be easilty done like this:

```typescript
m.makeAutoObservableController({
    async init() {
        // init is already a mobx action - no need for runInAction() here
        model.data = [];
        const data = await fetchData(); // data is of type MyData[]
        runInAction(() => {
            // we need to create an action "transaction" to change observable properties
            model.data = data;
        });
    },
});
```

As you can see, _init_ is a standard async function but there is a catch: all model (or controller) changes after the _await_ call need
to be encapsulated in a _runInAction()_ call.

This is actually the only "special" part of mobx that needs to be understood: mobx is a reactive
framework that is able to propagate changes to other objects (e.g. to update computed properties or to re-render a view),
but in order to be effective it needs all changes to be made in a kind of
_transaction_ (so that the propagation doesn't start too early). This is the goal of the mobx _actions_ (to be more precise, actions also
make sure that model changes are not done oustside the store controller - but this is less likely to happen with mom as the store model
is exposed as readonly outside the store factory implementation).

Note: all object methods created
through _makeAutoObservable_ are automatically wrapped into actions, so there is no need to use _runInAction()_ in synchronous methods.

Note 2: actions are needed for any changes on any observable object (so not only on models and controllers if you happen to create other observable objects).

Having said that, there is an alternate syntax based on generator functions that can be used instead of async functions:

```typescript
m.makeAutoObservableController({
    *init() {
        model.data = [];
        const data = (yield fetchData()) as MyData[]; // yield "loses" the return type -> a cast is needed
        model.data = data;
    },
});
```

As you can see, this syntax is much simpler (we basically need to change _await_ with _yield_ compared to an async function) - however here again there is a catch:
Typescript doesn't allow to type genererators so that the yield "returns" the same type as what was sent to the _yield_ operator - this is why an explicit cast is
needed.

As init() and dispose() are managed in the same way, the previous examples can be directly translated to dispose() (or any asynchronous function that need to be
exposed on the model or the controller).

Note: all object _generator_ methods created through _makeAutoObservable_ are automatically transformed into async functions - so these method signatures are changed, and
these methods must be called like any async functions (e.g. _await model.doSomething()_) and not like generator functions.

## Awaiting a store initialization / disposal

As store initializations are frequently asynchronous, mom exposes a specific **#initComplete** property to wait for the init completion. This property
is a promise that can be accessed like this:

```typescript
await store["#initComplete"];
```

Similarly, a **#diposeComplete** property is also available to wait for a store complete disposal:

```typescript
await store["#disposeComplete"];
```

## Store meta-data recap

As we saw in this chapter, mom exposes several life-cycle meta-data on all store models. The names of those meta-data properties always start with a "#" to
avoid any possible collision with the functional properties defined in the store model:

-   #state ("INITIALIZING" | "READY" | "DISPOSING" | "DISPOSED"): gives the current store life-cycle state
-   #ready (boolean): true when #state is "READY"
-   #initComplete (Promise): tell when init is complete (e.g. _await store["#initComplete"]_)
-   #disposeComplete (Promise): tell when the store is fully disposed.

On top of these properties, mom adds 2 extra meta-data:

-   #namespace (string) - this corresponds to the namespace value associated to the Store ID passed to the store factory (e.g. "mom.examples.basicCounter"
    for the BasicCounterIID example presented in one of the previous chapters). This namespace is particularly useful to differentitate sub-stores when
    a store reference may contain different kinds of stores. This namespace is also automatically added to mom's logs to identify the log source at a glance.
-   #id (string) - a unique store instance identifier composed of the store namespace combined with a unique
    instance count, separated with a hash (e.g. "mom.examples.basicCounter#123") - this id can be used for debugging or to have unique keys in React lists
-   #context (AsmContext) - the Dependency Inversion context - more on this in the DI chapter!
